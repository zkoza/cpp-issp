# Git

Git to obecnie najpopularniejszy, rozproszony system wersjonowania oprogramowania. Wersjonowanie polega na tworzeniu "migawek" czy swoistych "zdjęć" aktualnego stanu oprogramowania, powszechnie zwanych komitami (z angielskiego *commit*). Dzięki temu w każdej chwili można porównać np. bieżący stan jakiegoś pliku z tym sprzed jakichś zmian. Z kolei "rozproszony" oznacza, że nie istnieje jeden centralny serwer przechowujący repozytorium - zamiast tego każdy użytkownik danego repozytorium posiada u siebie lokalnie (czyli na własnym komputerze) pełną kopię całego repozytorium, z całą historią zmian. Oba te elementy, czyli migawki ("wersjonowanie") i rozproszenie (brak centralnego serwera) uzupełniane są o trzeci fundamentalny element: gałęzie (ang. *branches*). Łącznie tworzą system który bardzo, bardzo, bardzo ułatwia zarządzanie projektami programistycznymi (zwłaszcza tymi dużymi) i pracę w grupie. Taka praca z grubsza polega na tym (w bardzo dużym uproszczeniu), że jednym z "uczestników" grupy jest serwer ulokowany w chmurze (zwykle na serwisie BitBucket, GitHub lub GitLab, ale może to być też serwer prywatny lub firmowy), który służy jako uniwersalny pośrednik między członkami zespołu przechowujący "backup" projektu i ułatwiający synchronizację między członkami zespołu, z których każdy pracuje we własnym tempie nad innymi fragmentami projektu. W systemie git istnieje gałąź główna (zwykle zwana *master* lub *main*) przechowująca migawki oprogramowania w stanie, w którym ono działa stabilnie (niektóre z nich mogą być oznaczone specjalną etykietą ("otagowane", z ang. *tagged*) , np. numerem wersji programu). Programiści z ostatniej migawki w tej gałęzi tworzą osobną gałąź, która co prawda jest widoczna dla wszystkich, ale obowiązuje umowa, że nie pracuje się na nieswoich gałęziach. Na takiej bocznej gałęzi implementuje się nowa funkcjonalność lub usuwa zgłoszony błąd lub podejmuje inne czynności modyfikujące program. Ponieważ taka praca zwykle wymaga eksperymentowania i program od czasu do czasu po prostu przestaje działać prawidłowo, całą te pracę wykonuje się na osobnej gałęzi. Gdy pracujący na niej programista uzna, że jego zadnie zostało wykonane, zgłasza tzw. *pull request* (inna nazwa: *merge request*), jego poprawki są recenzowane przez innego członka (lub członków) zespołu i w przypadku akceptacji - włączane do gałęzi głównej (tę operacje nazywa się z angielskiego merdżowaniem, ang. *merging*). Gałąź robocza w tym momencie przestaje być użyteczna, zwykle się ją usuwa i tworzy nową, do realizacji nowego zadania. Cała trudność tego stylu pracy polega na tym, że zwykle jednocześnie otwartych jest kilkanaście czy nawet kilkadziesiąt gałęzi roboczych, w tym kilka w stanie "*pull request*", a praca w każdej z nich przebiuega we własnym tempie, co przypomina programowanie współbieżne. Ktokolwiek programował współbieżnie ten wie, że jego najtrudniejszą częścią jest synchronizacja. Popularność systemu git bierze się stąd, że dostarcza on znakomite narzędzia ułatwiające pracę w takim "współbieżnym środowisku programistycznym", w którym zmiany w gałęzi głównej pojawiają się często i w sposób zasadniczo niekontrolowany (a na pewno nie planowany) przez nikogo. Innymi słowy - mogę pracować nad swoim zdaniem przez 2 tygodnie, w tym czasie w gałęzi głównej mogło pojawić się kilkadziesiąt nowych migawek (komitów), a ja i tak mam spore szanse automatycznie wmerdżować swoją pracę do gałęzi głównej, a jeśli ta automatyka nie zadziała (co przypomina tzw. wyścig w programowaniu współbieżnym), to mam narzędzia do rozstrzygnięcia konfliktów, których nie można rozwiązać automatycznie.                       

### Rady dla osób początkujących

- Załóż sobie konto na jednym z serwisów (alfabetycznie) : [bitbucket.org](/bitbucket.org), [github.com]() lub [gitlab.com](). Z punktu widzenia osób początkujących wszystkie oferują podobne funkcjonalności, z punktu widzenia użytkowników zaawansowanych różnią się cennikami (w tym limitami zasobów w wersji darmowej) i dodatkowymi usługami (jak systemy kontroli przepływu pracy, organizacji automatycznego testowania itp.). Najpopularniejszy jest chyba GitHub, m.in. dlatego, że był jednym z pierwszych publicznych serwisów dla systemu git i w tamtych czasach zaczęto go powszechnie wykorzystywać w projektach typu OpenSource. Pozostałe dwa serwisy są jednak także bardzo dobre i oczywiście każdy z nich wykorzystywany jest też komercyjnie. Tu jest jedno opisów i porównań tych serwisów: [Github vs Gitlab vs Bitbucket](https://disbug.io/en/blog/github-vs-gitlab-vs-bitbucket). Historycznie ja jako pierwszy zacząłem używać BitBucket tylko z tego powodu, że wówczas w ramach licencji darmowej pozwalał na tworzenie repozytoriów prywatnych z dość dużą maksymalną liczbą użytkowników. Twoje priorytety mogą być inne.   

- Nowe projekty zakładaj w repozytorium chmurowym (BitBucket, GitHub, GitLab,...), klonuj je u siebie (czyli importuj puste repozytorium z serwera w chmurze) i od tej pory pracuj normalnie jak z repozytorium git. Przykład polecenia klonującego bieżący "podręcznik" za pomocą połączenia SSH:
  ```bash
  git clone git@github.com:zkoza/cpp-issp.git
  ```

  Alternatywne polecenie wykorzystuje do komunikacji z serwerem protokół HTTP:

  ```bash
  git clone https://github.com/zkoza/cpp-issp.git
  ```

  Konfigurację połączenia SSH opisuję gdzie indziej - dzięki niemu możesz się łączyć z serwerem bez konieczności każdorazowego podawania hasła. 

- Przed wykonaniem pierwszej migawki swojego projektu skonfiguruj swoje dane osobowe:

  ```bash
  git config --global user.name "Grzegorz Brzęczyszczykiewicz-Łękowodzki"
  git config --global user.email grzegorz.brzeczyszczykiewicz.lekowodzki@example.com
  ```

  Jeśli zamierzasz pracować na gałęziach, to pewnie będziesz potrzebować narzędzia do merdżowania. Ja używam programu `kdiff3`:

  ```bash 
  git config --global merge.tool kdiff3
  ```

- Zapoznaj się z podstawowymi koncepcjami gita.

  - **Katalog roboczy** (*working area*).  Gdy pracujemy nad projektem i dokonujemy w nim jakichś zmian, np. zapisując nową wersję jakiegoś pliku, to te zmiany zapisywane są w naszym katalogu roboczym (ang. *working directory* - to pojęcie występuje w dokumentacji systemu Git). Mówiąc "katalog roboczy" ma się na myśli katalog główny (to ten, w którym występuje podkatalog `.git`) projektu wraz z wszystkimi podkatalogami (z wyjątkiem podkatalogu `.git`).

  - **Repozytorium** to zbiór plików z informacjami umożliwiającymi odtworzenie w twoim katalogu roboczym dowolnej wersji twojego projektu (=migawki, czyli komitu)  zapisanej w tym repozytorium. Repozytorium projektu przechowywane jest w jego katalogu `.git`. 

  - **Migawka**, w slangu komuterowym - komit (ang. *commit*) - to wersja twojego projektu "zamrożona i zapamiętana" w określonej chwili czasu w repozytorium. Migawki mają swoje unikatowe identyfikatory (tzw. klucze SHA1). Poniższy rysunek to zrzut ekranu z fragmentu wyniku polecenia `git log` dla projektu, który czytasz. Te długie liczby szesnastkowe po słowach commit to właśnie ich identyfikatory, a napisy "drobne", "IMAGES 01" i "więcej o CMake" to komentarze do migawek.   

    ![git log](./img/01/git-log.png)

  - **Indeks** Git to obszar przejściowy (ang. *staging area*) pomiędzy katalogiem roboczym a repozytorium.  Gdy pracujesz nad projektem, w pewnym momencie dochodzisz do wniosku, że osiągnął on stan wart utrwalenia (np. przed synchronizacją z inną gałęzią). Zwykle zmianom uległo kilka, czasem kilkadziesiąt, zdarza się, że kilkaset plików (np. gdy zmieniasz nazwę jakiejś funkcji lub importujesz nową bibliotekę lub ktoś pomyli umówiony standard kodowania końca wierszy). Wśród tych zmian mogą być też takie, w których usuwasz jakieś pliki lub zmieniasz ich nazwy. Tak poważnych operacji nie robi się w jednym kroku, lepiej i bezpieczniej jest przygotować migawkę stopniowo, plik po pliku. Może to wyglądać tak:

    ```bash    
    git status
    git diff plik1.cpp
    vim plik1.cpp
    git diff plik1.cpp
    git add plik1.cpp
    git status
    git diff plik2.cpp
    vim plik2.cpp
    git diff plik2.cpp
    git add plik2.cpp
    ... (i tak dalej z każdym plikiem)
    ```

    Tutaj 

    - `git status` informuje, w których plikach dokonano zmian od ostatniego komita i czy w katalogu roboczym pojawiły się nowe pliki nieuwzględnione w repozytorium.
    - `git diff` informuje, jakich zmian dokonano w danym pliku od jego ostatniego zatwierdzenia w migawce. 
    - `vim` to edytor tekstu. Zwykle po komendzie `git diff` zauważasz, że twój plik nie jest w najlepszej kondycji i coś w nim jeszcze poprawiasz (np. usuwasz niepotrzebne komentarze czy nadajesz zmiennym bardziej użyteczne nazwy). Oczywiście `vim` to ostateczność, ja normalnie używam QtCreator-a.  
    - `git add plik` dodaje `plik` do indeksu, ale nie tworzy migawki

    Dopiero gdy w ten sposób przetworzę wszystkie pliki, tworzę migawkę poleceniem `git commit`. Może to trwać wiele godzin i wymagać wielokrotnego "dodawania" tego samego pliku poleceniem `git add`, gdyż zmiany w kolejnych plikach mogą wywoływać zmiany w już zatwierdzonych (np. wskutek zmiany nazw funkcji). Dla ciekawskich: indeks git znajduje się w jednym pliku (binarnym) o nazwie `index`, który przechowywany jest w katalogu `.git` projektu.         

    Ten obrazek może nieco pomóc w zrozumieniu, czym jest index ([żródło](https://www.javatpoint.com/git-index)):

    ![git index](./img/01/git-index.png)

- Zapoznaj się z podstawowymi poleceniami Git-a

  - Praca z repozytorium lokalnym (każde z poniższych poleceń ma dziesiątki dodatkowych opcji!):

    - `git add plik1 plik2 ...`   - dodaje plik lub pliki do indeksu

    - `git mv plik nowa_nazwa` - zmienia nazwę pliku i zapisuje tę informację w indeksie 

    - `git rm plik1 plik2 ...`  - usuwa plik z indeksu (i kolejnych migawek w repozytorium)

    - `git diff plik1` - wyświetla różnice między bieżącym stanem pliku a jego ostatnią "skomitowaną" (zatwierdzoną w repozytorium) wersją.  

    - `git status` - podaje stan katalogu roboczego względem indeksu i lokalnego repozytorium.

    - `git commit -m"komunikat"` - tworzy migawkę w repozytorium

    - `git log` - wyświetla informacje o migawkach 

    - `git log plik` - wyświetla informacje o migawka, które zmieniały dany plik

    - `git checkout plik` - przywraca z repozytorium do katalogu roboczego stan danego pliku zapisany w ostatniej migawce. Innymi słowy, anulujemy w ten sposób wszystkie nasze zmiany od ostatniego komitu.  

    - `git help nazwa_polecenia` - git ma niezwykle rozbudowany system pomocy!  Spróbuj `git gelp git` lub (Linux) `man gittutorial`. Niemniej, ja chyba wolę czytać dokumentację w przeglądarkach WWW.  

    - `git config --list` - wyświetla listę wszystkich parametrów konfiguracyjnych twojej instalacji i/lub projektu. W systemie Linux one są zwykle zapisane w pliku `.gitconfig`.  Możesz mieć jeden taki plik w swoim katalogu domowym (wtedy mówimy o ustawieniach globalnych, opcja `--global` do komendy `git config`) lub katalogu głównym projektu (ustawienia lokalne). Na przykład w tej chwili polecenie 

      ```bash
      git config --list --global
      ```

      zwraca

      ```
      user.email=zbignnoew.koza@uwr.edu.pl
      user.name=Zbigniew Koza
      merge.tool=kdiff3
      ```

      co oznacza, że mam w konfiguracji błąd. Mogę go naprawić poleceniem `git config --global user.email`, jak to opisałem powyżej,  lub bezpośrednio edytując plik `.gitconfig`.

  - Nieco bardziej zaawansowana praca z repozytorium lokalnym:

    - `git branch` - tworzy nową gałąź
    - `git switch nazwa_gałęzi` - przechodzi na inną gałąź, co zwykle wiąże się z podmianą plików w katalogu roboczym projektu
    - `git merge nazwa_gałęzi` - dołącza zmiany wykonane na bieżącej gałęzi do gałęzi `nazwa_gałęzi`. 
    - `git blame plik` - informuje, kto jest ostatnim autorem każdego wiersza  przechowywanego w repozytorium pliku `plik`.

  - Praca z repozytorium zdalnym:

    - `git push` - wysyła ("popycha") wszystkie nasze nowe migawki na serwer zdalny (domyślnie zwany `origin`) 
    - `git pull` - pobiera ("zaciąga") wszystkie nowe migawki, które mogły się pojawić na serwerze (`origin`) od ostatniej synchronizacji poleceniem `git pull`, a następnie łączy (merdżuje) je z naszym repozytorium.
    - `git fetch` - jak `git pull`, ale bez łączenia z lokalnym repozytorium.  Dzięki temu podejrzeć, jakie zmiany zaszły w repozytorium zdalnym.   

  

Sorki, nie da się w tak krótkim opracowaniu napisać o systemie git więcej. 



​     
